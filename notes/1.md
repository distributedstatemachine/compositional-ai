# Session 1: Categories as "Composition Interfaces"

## Overview

Categories are the mathematical foundation for understanding **composition**. In this session, we learn that a category is simply a collection of objects and morphisms (maps) between them, with a composition rule that is associative and has identities.

This "composition-first" perspective matches how we build ML pipelines and software systems.

## Key Concepts

### What is a Category?

A **category C** consists of:

1. **Objects**: A collection of "things" (e.g., types, sets, vector spaces)
2. **Morphisms**: For any two objects A, B, a set Hom(A, B) of "maps" from A to B
3. **Composition**: For morphisms f: A → B and g: B → C, a composite g ∘ f: A → C
4. **Identity**: For each object A, an identity morphism id_A: A → A

### The Laws

**Associativity**: For f: A → B, g: B → C, h: C → D:

```
(h ∘ g) ∘ f = h ∘ (g ∘ f)
```

**Identity**: For f: A → B:

```
f ∘ id_A = f = id_B ∘ f
```

### Diagram Notation

```
     f         g
A ───────► B ───────► C
│                     │
│      g ∘ f          │
└─────────────────────┘
```

## Examples of Categories

### 1. Set (Sets and Functions)

- **Objects**: Sets
- **Morphisms**: Functions between sets
- **Composition**: Function composition
- **Identity**: The identity function

### 2. Vect (Vector Spaces)

- **Objects**: Vector spaces over a field
- **Morphisms**: Linear maps
- **Composition**: Linear map composition
- **Identity**: The identity linear map

### 3. Types in Programming

- **Objects**: Types (Int, String, List[A], etc.)
- **Morphisms**: Pure functions between types
- **Composition**: Function composition
- **Identity**: The identity function `fn id<T>(x: T) -> T { x }`

### 4. ML Pipelines

- **Objects**: Tensor shapes (batch × features, etc.)
- **Morphisms**: Neural network layers
- **Composition**: Sequential layer composition
- **Identity**: Skip connections / identity layers

## Why "Composition-First" Thinking?

### Traditional OOP

```
class Pipeline:
    def __init__(self):
        self.layer1 = Layer1()
        self.layer2 = Layer2()
        self.layer3 = Layer3()

    def forward(self, x):
        x = self.layer1(x)
        x = self.layer2(x)
        x = self.layer3(x)
        return x
```

### Categorical / Compositional

```rust
let pipeline = layer1.then(layer2).then(layer3);
// Types enforce: output of layer1 = input of layer2
// Composition is the primary operation
```

**Benefits:**
- Type safety at composition boundaries
- Reusable combinators (then, parallel, etc.)
- Mathematical guarantees (associativity)
- Easier reasoning about complex systems

## Duality: The Opposite Category

Every category C has an **opposite category C^op** where:
- Same objects
- Arrows reversed: f: A → B in C becomes f^op: B → A in C^op
- Composition reversed: (g ∘ f)^op = f^op ∘ g^op

**Why this matters:**
- Autodiff (Session 9): Backward pass is a functor to the opposite category
- Many constructions come in "dual pairs" (products/coproducts, limits/colimits)

## Monoids: Single-Object Categories

A **monoid** is a category with exactly one object:
- The single object (call it *)
- Morphisms are "elements" of the monoid
- Composition is the monoid operation
- Identity morphism is the unit element

**Example**: Natural numbers under addition

```
Object: *
Morphisms: 0, 1, 2, 3, ...
Composition: m ∘ n = m + n
Identity: 0
```

This perspective reveals: **a monoid IS a category**, just a very simple one.

## Connection to This Course

| Session | Category | Objects | Morphisms |
|---------|----------|---------|-----------|
| 11-14 | FinStoch | Finite sets | Stochastic matrices |
| 14.5 | Gauss | Euclidean spaces | Gaussian kernels |
| 7-10 | Diff | Smooth manifolds | Differentiable maps |
| 15-16 | Pregroup | Grammar types | Reductions |

## Implementation Preview

```rust
/// A morphism in our system
pub trait Morphism {
    type Input;
    type Output;

    fn apply(&self, input: Self::Input) -> Self::Output;
}

/// Composition of morphisms
pub trait Composable<Other>: Morphism
where
    Other: Morphism<Input = Self::Output>,
{
    type Composed: Morphism<Input = Self::Input, Output = Other::Output>;

    fn then(self, other: Other) -> Self::Composed;
}
```

## Exercises

1. **Verify associativity**: For three functions f, g, h, show that (h ∘ g) ∘ f = h ∘ (g ∘ f) by evaluating both sides on an input x.

2. **Find the identity**: What is the identity morphism for:
   - A set A in Set?
   - A vector space V in Vect?
   - A type T in Rust?

3. **Opposite category**: If f: Int → String is `|n| format!("{}", n)`, what does f^op look like in Set^op?

4. **Monoid as category**: Express the string concatenation monoid as a one-object category.

## Reading

- Leinster, *Basic Category Theory*: Chapter 1
- Milewski, *Category Theory for Programmers*: "Categories Great and Small"

## Summary

| Concept | Definition |
|---------|------------|
| Category | Objects + morphisms + composition + identity |
| Morphism | Map from one object to another |
| Composition | Combining f: A→B and g: B→C into g∘f: A→C |
| Identity | id_A: A→A such that f∘id = f = id∘f |
| Associativity | (h∘g)∘f = h∘(g∘f) |
| Opposite | Same category with arrows reversed |

## Next

Session 2: Types/Shapes as Objects — treating tensor shapes as categorical objects with composability constraints.
