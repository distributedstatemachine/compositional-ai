# Session 19: Operads — Multi-Input Wiring Constraints

## Overview

This session introduces **operads** — structures that enforce arity constraints on composition. While diagrams allow arbitrary wiring if types match, operads add explicit **nesting structure** that prevents common wiring errors in multi-agent systems.

**Key insight**: Operads catch arity mismatches at the type level. If an agent expects 3 tool outputs, you can't accidentally wire only 2.

## Why Operads vs Plain Diagrams?

### Plain Diagrams

- Nodes + edges, any wiring allowed if types match
- Flexible but permissive
- Can accidentally wire wrong number of inputs

### Operads

- Explicit **nesting structure** — which operations can contain which
- Enforce **arity constraints** — operations have fixed input counts
- Enable **hierarchical composition** — operations can contain other operations

## Motivating Example: LLM Tool-Use Pipeline

```
Agent(3) — takes 3 tool outputs, produces 1 response
  ├── Tool("search")    — 1 query  → 1 result
  ├── Tool("calculate") — 2 numbers → 1 result
  └── Tool("fetch")     — 1 url    → 1 result

Valid wiring:   Agent receives (search_result, calc_result, fetch_result)
Invalid wiring: Agent receives (search_result, search_result) — wrong arity!
```

With plain `Diagram`: you could accidentally wire 2 inputs instead of 3.
With `Operad`: the operation signature `Agent(3)` enforces exactly 3 inputs.

## What Operads Catch That Diagrams Don't

1. **Arity mismatches** — wrong number of inputs
2. **Nesting violations** — operation A can't be inside operation B
3. **Scope constraints** — variable X only visible within block Y

## Core Types

### Operation

An operation with explicit arity:

```rust
/// An operation with explicit arity
pub struct Operation {
    /// Human-readable name
    pub name: String,
    /// Number of inputs expected
    pub arity: usize,
    /// Input shapes
    pub inputs: Vec<Shape>,
    /// Output shapes
    pub outputs: Vec<Shape>,
}
```

### WiringPlan

A wiring plan that enforces operadic constraints:

```rust
/// A wiring plan that enforces operadic constraints
pub struct WiringPlan {
    /// The outer operation receiving inputs
    pub outer: Operation,
    /// Inner operations providing inputs
    pub inner: Vec<Operation>,
    /// Wiring: (inner_op_idx, outer_slot_idx)
    pub wiring: Vec<(usize, usize)>,
}

impl WiringPlan {
    /// Validates that:
    /// 1. Number of inner operations == outer.arity
    /// 2. Each inner output shape matches expected outer input shape
    /// 3. No slot is wired twice
    pub fn validate(&self) -> Result<(), OperadError> { ... }

    /// Convert to a core::Diagram (loses arity enforcement)
    pub fn to_diagram(&self) -> Diagram<Operation> { ... }
}
```

### OperadError

```rust
pub enum OperadError {
    /// Wrong number of inputs for operation
    ArityMismatch {
        operation: String,
        expected: usize,
        got: usize,
    },
    /// Input/output shapes don't match
    ShapeMismatch {
        slot: usize,
        expected: Shape,
        got: Shape,
    },
    /// Same slot wired multiple times
    DuplicateWiring {
        slot: usize,
    },
    /// Referenced operation doesn't exist
    InvalidOperation {
        index: usize,
    },
}
```

## The Operadic Composition Pattern

### Simple Composition (1 output → 1 input)

```
┌─────────┐     ┌─────────┐
│    A    │────▶│    B    │
└─────────┘     └─────────┘

A;B : merge two operations in sequence
```

### Multi-Arity Composition (n outputs → 1 input)

```
┌─────────┐
│   A₁    │─┐
└─────────┘ │   ┌─────────┐
┌─────────┐ ├──▶│    B    │  B has arity 3
│   A₂    │─┤   └─────────┘
└─────────┘ │
┌─────────┐ │
│   A₃    │─┘
└─────────┘

compose(B; A₁, A₂, A₃) : plug 3 operations into B's inputs
```

### Nested Composition

Operations can contain other operations:

```
┌────────────────────────────────────┐
│  Outer(2)                          │
│  ┌─────────┐    ┌─────────────┐    │
│  │ Inner₁  │───▶│             │    │
│  └─────────┘    │   Inner₂    │────▶ output
│                 │   (arity 2) │    │
│  ┌─────────┐───▶│             │    │
│  │ Input   │    └─────────────┘    │
│  └─────────┘                       │
└────────────────────────────────────┘
```

## Agent/Tool Analogy

| Operad Concept | Agent Concept |
|----------------|---------------|
| Operation | Agent or Tool |
| Arity | Number of required inputs |
| Composition | Pipeline/orchestration |
| WiringPlan | Execution plan |
| Validation | Pre-flight checks |

## Why This Matters for AI Systems

### Tool-Using Agents

```rust
// Define operations
let agent = Operation::new("ReasoningAgent", 3)
    .with_inputs(vec![Shape::text(), Shape::text(), Shape::text()])
    .with_output(Shape::text());

let search = Operation::new("SearchTool", 0)
    .with_output(Shape::text());

let calculator = Operation::new("Calculator", 0)
    .with_output(Shape::text());

let fetch = Operation::new("WebFetch", 0)
    .with_output(Shape::text());

// Create valid wiring plan
let plan = WiringPlan::new(agent)
    .wire(search, 0)    // search output → agent slot 0
    .wire(calculator, 1) // calc output → agent slot 1
    .wire(fetch, 2);    // fetch output → agent slot 2

plan.validate()?;  // Ensures exactly 3 inputs

// This would fail:
let bad_plan = WiringPlan::new(agent)
    .wire(search, 0)
    .wire(calculator, 1);
    // Missing third input!

assert!(bad_plan.validate().is_err());  // ArityMismatch
```

### Multi-Agent Orchestration

```rust
// Orchestrator expects outputs from 4 specialist agents
let orchestrator = Operation::new("Orchestrator", 4);

let researcher = Operation::new("Researcher", 0);
let analyst = Operation::new("Analyst", 0);
let writer = Operation::new("Writer", 0);
let reviewer = Operation::new("Reviewer", 0);

let plan = WiringPlan::new(orchestrator)
    .wire(researcher, 0)
    .wire(analyst, 1)
    .wire(writer, 2)
    .wire(reviewer, 3);

// Type system guarantees all 4 agents are connected
```

## Connection to Session 18.5

The operadic structure complements lifetime-scoped agents:

- **Session 18.5**: Agents can't access resources outside their scope (lifetimes)
- **Session 19**: Agents can't receive wrong number of inputs (arity)

Together: compile-time guarantees for both resource access AND composition structure.

```rust
// Combining both patterns
struct ScopedOperation<'scope, S> {
    scope: &'scope S,
    operation: Operation,
}

impl<'scope, S> ScopedOperation<'scope, S>
where
    S: HasLLM + HasTools,
{
    fn compose_with<const N: usize>(
        &self,
        inner: [&ScopedOperation<'scope, S>; N],
    ) -> Result<WiringPlan, OperadError> {
        // Arity enforced by const generic N
        // Resource access enforced by lifetime 'scope
    }
}
```

## Comparison with Other Approaches

| Approach | Arity Check | Shape Check | Nesting | When |
|----------|-------------|-------------|---------|------|
| Plain functions | Runtime | Runtime | None | Runtime |
| Diagrams | None | Optional | None | Runtime |
| Operads | Required | Required | Enforced | Compile/Validate |
| Dependent types | Required | Required | Enforced | Compile |

## Implementation Sketch

```rust
/// Operation in an operad
#[derive(Debug, Clone)]
pub struct Operation {
    pub name: String,
    pub arity: usize,
    pub inputs: Vec<Shape>,
    pub outputs: Vec<Shape>,
}

impl Operation {
    pub fn new(name: impl Into<String>, arity: usize) -> Self {
        Self {
            name: name.into(),
            arity,
            inputs: Vec::new(),
            outputs: Vec::new(),
        }
    }

    pub fn with_inputs(mut self, inputs: Vec<Shape>) -> Self {
        assert_eq!(inputs.len(), self.arity, "inputs must match arity");
        self.inputs = inputs;
        self
    }

    pub fn with_outputs(mut self, outputs: Vec<Shape>) -> Self {
        self.outputs = outputs;
        self
    }
}

/// A validated wiring between operations
#[derive(Debug)]
pub struct WiringPlan {
    pub outer: Operation,
    pub inner: Vec<Operation>,
    pub wiring: Vec<(usize, usize)>,  // (inner_idx, slot_idx)
}

impl WiringPlan {
    pub fn validate(&self) -> Result<(), OperadError> {
        // Check arity
        if self.inner.len() != self.outer.arity {
            return Err(OperadError::ArityMismatch {
                operation: self.outer.name.clone(),
                expected: self.outer.arity,
                got: self.inner.len(),
            });
        }

        // Check shapes
        for (inner_idx, slot_idx) in &self.wiring {
            let inner_output = self.inner[*inner_idx]
                .outputs.first()
                .ok_or(OperadError::InvalidOperation { index: *inner_idx })?;

            let outer_input = self.outer.inputs.get(*slot_idx)
                .ok_or(OperadError::InvalidSlot { index: *slot_idx })?;

            if inner_output != outer_input {
                return Err(OperadError::ShapeMismatch {
                    slot: *slot_idx,
                    expected: outer_input.clone(),
                    got: inner_output.clone(),
                });
            }
        }

        // Check for duplicate wiring
        let mut wired_slots = std::collections::HashSet::new();
        for (_, slot_idx) in &self.wiring {
            if !wired_slots.insert(*slot_idx) {
                return Err(OperadError::DuplicateWiring { slot: *slot_idx });
            }
        }

        Ok(())
    }
}
```

## Exercises

1. **Create a tool pipeline**: Define operations for a search → summarize → respond pipeline. Validate the wiring.

2. **Arity mismatch**: Create a WiringPlan with wrong arity and observe the error.

3. **Shape mismatch**: Create operations with incompatible shapes and validate.

4. **Nested operations**: Implement a two-level hierarchy where inner operations themselves have arity > 0.

5. **Convert to Diagram**: Implement `to_diagram()` that converts a validated WiringPlan to `Diagram<Operation>`.

## Summary

| Concept | Purpose |
|---------|---------|
| Operation | Named process with fixed input arity |
| WiringPlan | Validated connection of operations |
| Arity | Number of inputs an operation requires |
| Validation | Pre-flight check that wiring is correct |

## Key Takeaways

1. **Operads enforce arity** — can't wire wrong number of inputs
2. **Structure before execution** — validate before running
3. **Hierarchical composition** — operations can nest
4. **Complements lifetimes** — arity + resource control = safe agents

## Reading

- Spivak: wiring diagrams / operad intuition notes
- Optional: "Operads for complex system design"
- Existing codebase: `compositional_core::Diagram` for comparison

## Next

Session 20: Integration — unifying all crates for the capstone project.
