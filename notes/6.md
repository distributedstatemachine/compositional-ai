# Session 6: String Diagram UX — Render, DOT Export & Zero-Cost Tracing

*Reading: Seven Sketches — string diagram reasoning (skim); Optional: Graphviz DOT primer*

---

## Why Diagram Rendering Matters

Diagrams are programs. But unlike text-based code, their structure is inherently **visual**:

```text
              ┌─────────────────┐
   query ─────│ WebSearch(tech) │─────┐
              └─────────────────┘     │    ┌───────────┐
                                      ├────│ Synthesis │──── report
              ┌─────────────────┐     │    └───────────┘
   query ─────│ WebSearch(acad) │─────┘
              └─────────────────┘
```

You debug by **seeing**:
- Which nodes exist
- How data flows between them
- Where shapes mismatch
- What the boundaries are

Without rendering, a diagram is just an opaque graph. With rendering, it becomes comprehensible.

---

## Two Rendering Approaches

### 1. ASCII Rendering (`render_ascii`)

Simple, terminal-friendly output for quick inspection:

```rust
impl<O: Debug> Diagram<O> {
    pub fn render_ascii(&self) -> String {
        let mut out = String::new();

        // Header
        writeln!(out, "Diagram: {} nodes, {} edges",
                 self.node_count(), self.edge_count()).unwrap();
        writeln!(out, "Inputs: {:?}", self.inputs).unwrap();
        writeln!(out, "Outputs: {:?}", self.outputs).unwrap();
        writeln!(out).unwrap();

        // Nodes
        for (idx, node) in self.graph.node_indices().zip(self.graph.node_weights()) {
            writeln!(out, "[{:?}] {:?}", idx, node.op).unwrap();
            for (i, port) in node.inputs.iter().enumerate() {
                writeln!(out, "  in[{}]: {}", i, port.shape).unwrap();
            }
            for (i, port) in node.outputs.iter().enumerate() {
                writeln!(out, "  out[{}]: {}", i, port.shape).unwrap();
            }
        }

        // Edges
        writeln!(out, "\nEdges:").unwrap();
        for edge in self.graph.edge_references() {
            writeln!(out, "  {:?}:{} -> {:?}:{}",
                     edge.source(), edge.weight().from_port,
                     edge.target(), edge.weight().to_port).unwrap();
        }

        out
    }
}
```

Example output:

```text
Diagram: 3 nodes, 2 edges
Inputs: [(NodeIndex(0), 0), (NodeIndex(1), 0)]
Outputs: [(NodeIndex(2), 0)]

[NodeIndex(0)] Input
  out[0]: f32[128]
[NodeIndex(1)] Input
  out[0]: f32[128]
[NodeIndex(2)] Add
  in[0]: f32[128]
  in[1]: f32[128]
  out[0]: f32[128]

Edges:
  NodeIndex(0):0 -> NodeIndex(2):0
  NodeIndex(1):0 -> NodeIndex(2):1
```

### 2. Graphviz DOT Export (`to_dot`)

For visualization tools (renders to SVG, PNG, etc.):

```rust
impl<O: Debug> Diagram<O> {
    pub fn to_dot(&self) -> String {
        let mut out = String::new();

        writeln!(out, "digraph {{").unwrap();
        writeln!(out, "  rankdir=LR;").unwrap();  // Left-to-right flow
        writeln!(out, "  node [shape=box];").unwrap();

        // Nodes
        for idx in self.graph.node_indices() {
            let node = self.graph.node_weight(idx).unwrap();
            let label = format!("{:?}\\n{} in, {} out",
                               node.op, node.num_inputs(), node.num_outputs());
            writeln!(out, "  n{} [label=\"{}\"];", idx.index(), label).unwrap();
        }

        // Edges with port labels
        for edge in self.graph.edge_references() {
            let e = edge.weight();
            writeln!(out, "  n{} -> n{} [label=\"{}→{}\"];",
                     edge.source().index(), edge.target().index(),
                     e.from_port, e.to_port).unwrap();
        }

        // Mark boundary nodes
        for (node, _) in &self.inputs {
            writeln!(out, "  n{} [style=filled, fillcolor=lightblue];",
                     node.index()).unwrap();
        }
        for (node, _) in &self.outputs {
            writeln!(out, "  n{} [style=filled, fillcolor=lightgreen];",
                     node.index()).unwrap();
        }

        writeln!(out, "}}").unwrap();
        out
    }
}
```

Use with Graphviz:

```bash
cargo run -p demos -- render --dot > diagram.dot
dot -Tsvg diagram.dot -o diagram.svg
```

---

## Zero-Cost Tracing: A Rust-Native Advantage

In Python agent frameworks, tracing is typically always-on:

```python
# Python: tracing always runs, always costs time/tokens
@trace
async def agent_call(input):
    start = time.time()
    result = await llm.complete(input)
    log_trace(time.time() - start, result)  # Always executes
    return result
```

In Rust, we can use **const generics** for zero-cost abstraction:

```rust
/// Const generic toggle — zero cost when disabled
pub struct Traced<C, const ENABLED: bool> {
    inner: C,
}
```

### When Tracing is Disabled

```rust
impl<C: Computation> Computation for Traced<C, false> {
    type Input = C::Input;
    type Output = C::Output;  // Same output type!

    async fn run(&self, input: Self::Input) -> Result<Self::Output, CoreError> {
        // No tracing code generated — zero overhead
        // The compiler eliminates this wrapper entirely
        self.inner.run(input).await
    }
}
```

When `ENABLED = false`:
- No timing code
- No allocation for traces
- No logging overhead
- **Identical to running without the wrapper**

### When Tracing is Enabled

```rust
impl<C: Computation> Computation for Traced<C, true> {
    type Input = C::Input;
    type Output = (C::Output, TraceNode);  // Output includes trace!

    async fn run(&self, input: Self::Input) -> Result<Self::Output, CoreError> {
        let start = std::time::Instant::now();
        let result = self.inner.run(input).await?;
        let trace = TraceNode {
            duration: start.elapsed(),
            type_name: std::any::type_name::<C>(),
        };
        Ok((result, trace))
    }
}
```

When `ENABLED = true`:
- Full timing information
- Type names for debugging
- Trace tree construction
- **Zero runtime checks** — the decision is compile-time

### Compile-Time Selection

```rust
/// Debug builds: full tracing
#[cfg(debug_assertions)]
pub type TracedDiagram<O> = Traced<Diagram<O>, true>;

/// Release builds: zero overhead
#[cfg(not(debug_assertions))]
pub type TracedDiagram<O> = Traced<Diagram<O>, false>;
```

Same code, different behavior:

```bash
cargo run           # Debug: full tracing, detailed logs
cargo run --release # Release: zero tracing overhead
```

---

## The TraceNode Structure

```rust
#[derive(Debug, Clone)]
pub struct TraceNode {
    /// How long this computation took
    pub duration: std::time::Duration,
    /// The type name of the computation
    pub type_name: &'static str,
    /// Child traces (for composed computations)
    pub children: Vec<TraceNode>,
}

impl TraceNode {
    pub fn new(duration: std::time::Duration, type_name: &'static str) -> Self {
        Self {
            duration,
            type_name,
            children: Vec::new(),
        }
    }

    /// Pretty-print the trace tree
    pub fn display(&self, indent: usize) -> String {
        let mut out = String::new();
        let prefix = "  ".repeat(indent);
        writeln!(out, "{}[{:?}] {}", prefix, self.duration, self.type_name).unwrap();
        for child in &self.children {
            out.push_str(&child.display(indent + 1));
        }
        out
    }
}
```

Example trace output:

```text
[152.3ms] Pipeline<ResearchAgent, SynthesisAgent>
  [89.1ms] ParallelAgents<WebSearchAgent>
    [45.2ms] WebSearchAgent("technical")
    [43.9ms] WebSearchAgent("academic")
  [63.2ms] SynthesisAgent
```

---

## Why This Matters: The Rewrite Mindset

String diagram rendering enables **rewrite-based reasoning**:

1. **Visualize** the current structure
2. **Identify** optimization opportunities
3. **Apply** rewrites (interchange, fusion, etc.)
4. **Verify** the result visually

The interchange law from Session 5 becomes visible:

```text
Before: (f₁ ; g₁) ⊗ (f₂ ; g₂)

┌────┐    ┌────┐
│ f₁ │────│ g₁ │
└────┘    └────┘

┌────┐    ┌────┐
│ f₂ │────│ g₂ │
└────┘    └────┘

After: (f₁ ⊗ f₂) ; (g₁ ⊗ g₂)

┌────┐         ┌────┐
│ f₁ │─────────│ g₁ │
└────┘         └────┘

┌────┐         ┌────┐
│ f₂ │─────────│ g₂ │
└────┘         └────┘
```

Both are equivalent — same semantics, different execution order.

---

## The Computation Trait

For tracing to work, we need a common interface:

```rust
/// A computation that can be run with input to produce output
pub trait Computation {
    type Input: Send;
    type Output: Send;

    fn run(&self, input: Self::Input)
        -> impl Future<Output = Result<Self::Output, CoreError>> + Send;
}
```

This is similar to `Agent` from Session 5, but more general. Diagrams, agents, and composed pipelines all implement `Computation`.

---

## Summary

| Concept | Purpose |
|---------|---------|
| `render_ascii()` | Quick terminal inspection |
| `to_dot()` | Visual graph rendering |
| `Traced<C, false>` | Zero-cost wrapper (release) |
| `Traced<C, true>` | Full tracing (debug) |
| `TraceNode` | Hierarchical timing data |
| Const generics | Compile-time feature toggle |

**Key insight**: Rust's type system lets us have **zero-cost abstractions** that other languages can't achieve. The same code compiles to completely different behavior based on build configuration — no runtime checks, no overhead, no compromise.
