# Session 18.5: Compile-Time Agent Safety — Lifetimes as Sandboxes

## Overview

This session explores how Rust's type system provides **compile-time safety guarantees** for agents that other languages achieve through runtime sandboxing. The key insight: lifetime-scoped agents and `Send`/`Sync` traits give us zero-cost isolation.

**Key insight**: The borrow checker is a sandbox — agents literally cannot access what's not in their scope!

## Why Python Needs Sandboxes, Rust Doesn't

### Python Approach (Runtime Isolation)

Python agent frameworks like Agentica use:
- **WASM sandboxes**: Isolate agent execution
- **MicroVMs**: Hardware-level isolation
- **Runtime overhead**: Constant checking during execution

```python
# Python: Runtime sandbox required
with Sandbox() as sandbox:
    agent = Agent(sandbox)
    result = agent.run(task)  # Checked at runtime
# Hope nothing leaked...
```

### Rust Approach (Compile-Time Isolation)

Rust provides:
- **Borrow checker**: Enforces isolation at compile time
- **Lifetime annotations**: Scope is explicit in types
- **Zero runtime overhead**: All checks happen before execution

```rust
// Rust: Compiler enforces isolation
fn run_agent() {
    let resources = Resources::new();
    {
        let agent = Agent::new(&resources, config);
        agent.call("task").await;
    }  // agent dropped, borrow ends

    // resources still valid, agent gone
    // No leaks, no dangling refs — COMPILER PROVED IT
}
```

## Lifetime-Scoped Agents

### The Pattern

An agent borrows its scope — it cannot outlive the resources it uses:

```rust
/// Agent borrows scope — cannot outlive it
struct Agent<'scope, S> {
    scope: &'scope S,
    config: AgentConfig,
}

impl<'scope, S> Agent<'scope, S>
where
    S: HasDatabase + HasLLM,
{
    fn new(scope: &'scope S, config: AgentConfig) -> Self {
        Self { scope, config }
    }

    async fn call(&self, task: &str) -> Result<Output, AgentError> {
        // Can access scope.db(), scope.llm()
        // Cannot store references beyond 'scope lifetime
        let data = self.scope.db().query(task).await?;
        self.scope.llm().process(&data).await
    }
}
```

### What the Lifetime Guarantees

The `'scope` lifetime annotation means:
1. Agent cannot outlive its resources
2. Agent cannot store dangling references
3. When scope ends, agent is automatically dropped
4. Resources remain valid after agent is gone

```rust
fn example() {
    let resources = Resources::new();

    {
        let agent = Agent::new(&resources, config);
        // agent.scope has lifetime of this block
        agent.call("task").await;
    }  // agent dropped here

    // resources still usable!
    resources.cleanup();
}
```

### Contrast with Garbage Collection

| Aspect | GC Languages | Rust |
|--------|--------------|------|
| When checked | Runtime | Compile time |
| Overhead | GC pauses | Zero |
| Leaks possible? | Yes (cycles, forgotten refs) | No (compiler prevents) |
| Dangling refs? | No (but may hold too long) | No (provably impossible) |

## Parallel Safety via Send + Sync

### The Two Traits

Rust has two marker traits for thread safety:

**`Send`**: Type can be *transferred* to another thread
```rust
// T: Send means you can move T to another thread
fn spawn<T: Send>(value: T) { ... }
```

**`Sync`**: Type can be *shared* between threads via `&T`
```rust
// T: Sync means &T is Send
// Multiple threads can have &T simultaneously
fn share<T: Sync>(value: &T) { ... }
```

### Compiler Proves Safety

Data races are **compile errors**, not runtime bugs:

```rust
/// Parallel execution — compiler enforces safety
async fn parallel_agents<S>(scope: Arc<S>) -> (A, B)
where
    S: HasDatabase + HasLLM + Send + Sync,
{
    // Arc<S> is Send — can be moved to other tasks
    // S: Sync — &S can be shared across threads

    let scope1 = scope.clone();
    let scope2 = scope.clone();

    tokio::join!(
        tokio::spawn(async move {
            let agent = Agent::new(&*scope1, config_a);
            agent.call("task A").await
        }),
        tokio::spawn(async move {
            let agent = Agent::new(&*scope2, config_b);
            agent.call("task B").await
        })
    )
}
```

### What Won't Compile

```rust
// This won't compile — Rc is not Send!
fn bad_parallel() {
    let shared = Rc::new(Resources::new());

    tokio::spawn(async move {
        // ERROR: Rc<Resources> cannot be sent between threads
        use_resources(&shared);
    });
}

// This won't compile — RefCell is not Sync!
fn bad_sharing() {
    let shared = Arc::new(RefCell::new(data));

    // ERROR: RefCell<T> cannot be shared between threads
    let handle1 = spawn(|| shared.borrow());
    let handle2 = spawn(|| shared.borrow_mut());
}
```

## Capability-Based Security

### Traits as Capabilities

Define what an agent can access through trait bounds:

```rust
/// Capability traits
trait HasDatabase {
    fn db(&self) -> &Database;
}

trait HasLLM {
    fn llm(&self) -> &LLMClient;
}

trait HasFileSystem {
    fn fs(&self) -> &FileSystem;
}

/// Agent with specific capabilities
impl<'scope, S> Agent<'scope, S>
where
    S: HasDatabase + HasLLM,  // Only these capabilities!
{
    async fn call(&self, task: &str) -> Result<Output, AgentError> {
        // Can use: self.scope.db(), self.scope.llm()
        // Cannot use: self.scope.fs() — not in bounds!
    }
}
```

### Principle of Least Privilege

```rust
/// Minimal scope — only what's needed
struct MinimalScope {
    db: Database,
}

impl HasDatabase for MinimalScope {
    fn db(&self) -> &Database { &self.db }
}

// Agent can ONLY access database
// Compiler ensures no other access is possible
let agent = Agent::new(&minimal_scope, config);
```

## Comparison with Other Approaches

### WASM Sandbox (Wasmtime, etc.)

```
Compile → WASM bytecode → Runtime sandbox → Execute
                              ↓
                         Runtime checks
                         Memory isolation
                         Capability limits
```

**Overhead**: Every memory access checked at runtime.

### Rust Lifetimes

```
Compile → Borrow check → Prove safety → Native code
              ↓
         Zero runtime cost
         Static guarantees
         No sandbox needed
```

**Overhead**: Zero at runtime — all work done at compile time.

## Implementation Sketch

```rust
use std::sync::Arc;

/// Resources that agents can access
pub struct AgentScope {
    db: Database,
    llm: LLMClient,
}

impl HasDatabase for AgentScope {
    fn db(&self) -> &Database { &self.db }
}

impl HasLLM for AgentScope {
    fn llm(&self) -> &LLMClient { &self.llm }
}

/// Lifetime-scoped agent
pub struct ScopedAgent<'scope, S> {
    scope: &'scope S,
    name: String,
}

impl<'scope, S> ScopedAgent<'scope, S>
where
    S: HasDatabase + HasLLM + Send + Sync,
{
    pub fn new(scope: &'scope S, name: impl Into<String>) -> Self {
        Self {
            scope,
            name: name.into(),
        }
    }

    pub async fn execute(&self, task: &str) -> Result<String, AgentError> {
        // Query database
        let context = self.scope.db().query(task).await?;

        // Call LLM
        let response = self.scope.llm().complete(&context).await?;

        Ok(response)
    }
}

/// Parallel agent execution
pub async fn run_parallel<S>(
    scope: Arc<S>,
    tasks: Vec<String>,
) -> Vec<Result<String, AgentError>>
where
    S: HasDatabase + HasLLM + Send + Sync + 'static,
{
    let handles: Vec<_> = tasks
        .into_iter()
        .map(|task| {
            let scope = scope.clone();
            tokio::spawn(async move {
                let agent = ScopedAgent::new(&*scope, "worker");
                agent.execute(&task).await
            })
        })
        .collect();

    futures::future::join_all(handles)
        .await
        .into_iter()
        .map(|r| r.unwrap())
        .collect()
}
```

## The Category Theory Connection

### Agents as Morphisms

In categorical terms:
- **Objects**: Resource types (Database, LLM, etc.)
- **Morphisms**: Agents that transform resources to outputs
- **Composition**: Agent pipelines

```rust
// Agent: Scope → Output
// Composition: (Scope → A) ; (A → B) = (Scope → B)
```

### Lifetimes as Scoped Morphisms

The lifetime `'scope` is a **categorical constraint**:
- Morphism only exists within scope
- Automatically "garbage collected" when scope ends
- Composition respects scope boundaries

## Exercises

1. **Lifetime error**: Write code where an agent tries to outlive its scope. Observe the compile error.

2. **Send bound**: Create a type that's not `Send` and try to use it across threads. Explain the error.

3. **Capability restriction**: Design a scope that only provides read-only database access. Ensure the agent can't write.

4. **Parallel safety**: Implement two agents that share a resource safely using `Arc<RwLock<T>>`.

## Summary

| Concept | Python/JS | Rust |
|---------|-----------|------|
| Isolation | Runtime sandbox | Compile-time lifetimes |
| Thread safety | Locks + hope | `Send`/`Sync` proofs |
| Capability control | Runtime checks | Trait bounds |
| Overhead | Always present | Zero at runtime |
| Guarantees | "Should work" | "Will work or won't compile" |

## Key Takeaways

1. **Lifetimes are sandboxes**: Agent cannot access outside its scope
2. **Send/Sync are proofs**: Compiler verifies thread safety
3. **Traits are capabilities**: Bound what agents can access
4. **Zero cost**: All checks at compile time

## Reading

- Rust Book: Lifetimes, `Send`, `Sync` traits
- Tokio docs: Spawning tasks with `Send` bounds
- `docs/rust-native-agents.md`: Lifetime-scoped agents
- Jon Gjengset: "Rust for Rustaceans" — Advanced lifetimes

## Next

Session 19: Agent composition patterns — building complex agents from simple ones using categorical composition.
