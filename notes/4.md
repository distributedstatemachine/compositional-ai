# Session 4: String Diagrams — Programs as Pictures

*Reading: Fong & Spivak, Seven Sketches — string diagrams / monoidal categories sections*

---

## The Core Idea

A **string diagram** represents computation as:
- **Boxes** (nodes): Operations/functions/morphisms
- **Wires** (edges): Data flowing between operations
- **Boundaries**: Inputs on the left, outputs on the right

```
    Input wires          Output wires
         │                    │
         ▼                    ▼
    ───────┐              ┌───────
           │    ┌─────┐   │
    ────────────│  f  │───────────
           │    └─────┘   │
    ───────┘              └───────
```

---

## Why "A Diagram is a Program"

Consider this Python pipeline:

```python
def pipeline(text):
    tokens = tokenize(text)
    embeddings = embed(tokens)
    result = classify(embeddings)
    return result
```

As a string diagram:

```
            ┌───────────┐    ┌─────────┐    ┌──────────┐
   text ────│ tokenize  │────│  embed  │────│ classify │──── result
            └───────────┘    └─────────┘    └──────────┘
```

The diagram **is** the program — it captures:
1. What operations exist
2. How data flows between them
3. The composition structure

---

## Sequential Composition: Wiring Outputs to Inputs

When the output type of `f` matches the input type of `g`, we can compose:

```
   f: A → B      g: B → C

   ┌───┐         ┌───┐              ┌───┐    ┌───┐
───│ f │───  ;  ─│ g │───   =    ───│ f │────│ g │───
   └───┘         └───┘              └───┘    └───┘
   A → B         B → C                  A → C

   "f then g" = sequential composition
```

This is categorical composition: `g ∘ f` (or `f ; g` in diagram order).

**Key insight**: Composition is only valid when types match — the wire connecting them must have a consistent type (B in this case).

---

## Parallel Composition: Monoidal Product (⊗)

What if we want to run things **side by side**?

```
   f: A → B      g: C → D

   ┌───┐                           ┌───┐
───│ f │───                     ───│ f │───
   └───┘         ⊗                 └───┘
   ┌───┐                           ┌───┐
───│ g │───                     ───│ g │───
   └───┘                           └───┘

   f ⊗ g: (A, C) → (B, D)
```

This is the **monoidal product** — parallel composition. In code:

```rust
// Sequential: f then g
let result = g(f(input));

// Parallel: f and g simultaneously
let (result_f, result_g) = (f(input_a), g(input_c));
```

---

## Boundaries = Interfaces

The **boundary** of a diagram defines its interface:

```
    Left boundary          Right boundary
    (inputs)               (outputs)
         │                      │
         ▼                      ▼
    ┌────────────────────────────────┐
    │                                │
────│         Some Diagram           │────
────│                                │────
    │                                │
    └────────────────────────────────┘
```

- **Open diagram**: Has dangling wires (inputs/outputs) — can be composed with others
- **Closed diagram**: No dangling wires — a complete computation

---

## Why This Matters for AI Systems

In Agentica/agent frameworks, the same structure appears:

```
                    ┌─────────────┐
   user_query ──────│   Agent 1   │──────┐
                    │  (research) │      │     ┌─────────────┐
                    └─────────────┘      ├─────│   Agent 3   │──── final_report
                    ┌─────────────┐      │     │  (combine)  │
   context ─────────│   Agent 2   │──────┘     └─────────────┘
                    │  (analyze)  │
                    └─────────────┘

   Parallel agents feed into a combining agent
```

This is a string diagram! The categorical perspective gives us:
- **Type safety**: Wires must match (Shape compatibility)
- **Compositionality**: Build complex systems from simple parts
- **Optimization**: Rewrite rules that preserve semantics

---

## The Monoidal Category Structure

A **monoidal category** has:

| Component | Description | In Our System |
|-----------|-------------|---------------|
| Objects | Types | `Shape` |
| Morphisms | Operations | Diagram nodes |
| Sequential (`;`) | Connect output→input | `diagram.then(other)` |
| Parallel (`⊗`) | Run side by side | `diagram.tensor(other)` |
| Unit (`I`) | Empty wire / unit type | `()` or empty tuple |

### The Laws

These ensure composition behaves sensibly:

```
Associativity:    (f ; g) ; h  =  f ; (g ; h)
Identity:         id ; f  =  f  =  f ; id
Interchange:      (f₁ ; g₁) ⊗ (f₂ ; g₂)  =  (f₁ ⊗ f₂) ; (g₁ ⊗ g₂)
```

The **interchange law** is particularly important — it says you can:
1. First compose sequentially, then put in parallel, OR
2. First put in parallel, then compose sequentially

Same result either way!

---

## In the Codebase

The `Diagram<Op>` struct captures this:

```rust
// From crates/core/src/diagram.rs
pub struct Diagram<Op> {
    nodes: Vec<Node<Op>>,      // The boxes
    edges: Vec<Edge>,          // The wires
    inputs: Vec<PortId>,       // Left boundary
    outputs: Vec<PortId>,      // Right boundary
}
```

Composition operations:

```rust
impl<Op> Diagram<Op> {
    /// Sequential: self ; other (connect outputs to inputs)
    fn then(self, other: Diagram<Op>) -> Result<Diagram<Op>, ShapeMismatch>;

    /// Parallel: self ⊗ other (side by side)
    fn tensor(self, other: Diagram<Op>) -> Diagram<Op>;
}
```

---

## Fong & Spivak's Key Points

From *Seven Sketches*:

1. **Diagrams are first-class**: Not just visualization — the actual mathematical object
2. **Composition is the main operation**: Everything is about how things connect
3. **Types enforce correctness**: Wires carry type information; mismatches are errors
4. **Semantics via functors**: Map diagrams to actual computations (execute them)

---

## Summary

| Concept | Meaning |
|---------|---------|
| Box | An operation/morphism |
| Wire | Data flow / typed connection |
| Left boundary | Inputs to the diagram |
| Right boundary | Outputs from the diagram |
| Sequential (`;`) | Connect end-to-end |
| Parallel (`⊗`) | Side by side |
| Open diagram | Has dangling wires — composable |
| Closed diagram | No dangling wires — complete program |

**The insight**: A diagram isn't a picture of a program — it **is** the program, in a form that makes composition explicit and type-safe.
