# Session 17: Open Games — Compositional Game Theory

## Overview

Open games provide a **compositional framework for game theory** where:
- Games are modular components (boxes) with typed interfaces
- Complex games are built by composing simpler ones
- Strategy, environment, and objectives can be swapped independently
- The categorical structure ensures well-defined composition

**Key insight**: Games are morphisms in a category, just like functions or processes!

## Motivation: Why Compositional Games?

### Traditional Game Theory Problems

Classical game theory treats games as monolithic objects:
- Hard to decompose into reusable parts
- Difficult to modify one component without changing everything
- No clear notion of "subgame" composition
- Equilibrium analysis doesn't compose well

### The Compositional Solution

Open games treat games as **boxes with interfaces**:

```
         ┌─────────┐
   X ───▶│  Game   │───▶ Y
         │         │
   R ◀───│         │◀─── S
         └─────────┘

X = input observations (what the player sees)
Y = output actions (what the player does)
R = input utility (reward received)
S = output utility (reward passed on)
```

This is a **bidirectional** or **lens-like** structure!

## The Category of Open Games

### Objects

Objects are **types** representing:
- Observation spaces (what players can see)
- Action spaces (what players can do)
- Utility types (rewards/payoffs)

### Morphisms

A morphism (open game) `G: (X, S) → (Y, R)` consists of:

1. **Play function**: `play: X × Σ → Y`
   - Given observation X and strategy Σ, produce action Y

2. **Coplay function**: `coplay: X × Σ × R → S`
   - Given observation, strategy, and received reward, compute passed-on reward

3. **Equilibrium condition**: `equilibrium: X × (Y → R) → P(Σ)`
   - Given observation and continuation, which strategies are equilibria?

### Composition

Sequential composition `G ; H`:

```
         ┌─────┐     ┌─────┐
   X ───▶│  G  │───▶│  H  │───▶ Z
         │     │     │     │
   R ◀───│     │◀───│     │◀─── T
         └─────┘     └─────┘
```

- Play: `play_H(play_G(x, σ_G), σ_H)`
- Coplay: `coplay_G(x, σ_G, coplay_H(y, σ_H, t))`
- Equilibrium: Both G and H must be in equilibrium

### Parallel Composition

Tensor product `G ⊗ H`:

```
         ┌─────┐
  X₁ ───▶│  G  │───▶ Y₁
         └─────┘
         ┌─────┐
  X₂ ───▶│  H  │───▶ Y₂
         └─────┘
```

Players act independently on separate "channels".

## Example: Simple Decision

A single decision with utility:

```rust
/// A simple decision game
struct Decision<X, Y, R> {
    /// Available actions given observation
    actions: fn(X) -> Vec<Y>,
    /// Utility function
    utility: fn(X, Y) -> R,
}
```

As an open game:
- Play: choose action from available set
- Coplay: pass through utility
- Equilibrium: actions maximizing expected utility

## Example: Sequential Game

Player 1 moves, then Player 2 responds:

```
         ┌─────────┐     ┌─────────┐
   () ──▶│ Player1 │───▶│ Player2 │───▶ ()
         │         │     │         │
   R₁ ◀──│         │◀────│         │◀─── ()
         └─────────┘     └─────────┘
                           │
                           ▼
                          R₂
```

Composition handles:
- Information flow (P1's action visible to P2)
- Backward induction (P2's response affects P1's utility)

## Connection to Lenses

Open games generalize **lenses** from functional programming:

```haskell
-- A lens
data Lens s t a b = Lens {
    view :: s -> a,
    update :: s -> b -> t
}

-- An open game (simplified)
data OpenGame x s y r = OpenGame {
    play :: x -> y,
    coplay :: x -> r -> s
}
```

The forward direction is "play", backward is "coplay" (utility flow).

## Swapping Components

The compositional structure lets us swap parts independently:

### Swap the Policy

```
         ┌─────────┐
   X ───▶│ Policy₁ │───▶ Y     →    ┌─────────┐
         └─────────┘           X ───▶│ Policy₂ │───▶ Y
                                     └─────────┘
```

Same environment, different decision rule.

### Swap the Environment

```
         ┌─────┐              ┌─────┐
   X ───▶│ Env₁│───▶          │ Env₂│───▶
         └─────┘              └─────┘
```

Same policy, different world dynamics.

### Swap the Objective

```
   R₁ ◀─── ...        →      R₂ ◀─── ...
```

Same game structure, different reward function.

## Implementation Sketch

```rust
/// An open game with observation X, action Y, and utilities R, S
pub struct OpenGame<X, Y, R, S, Σ> {
    /// Strategy space
    strategy_space: PhantomData<Σ>,

    /// Play function: observation × strategy → action
    play: Box<dyn Fn(&X, &Σ) -> Y>,

    /// Coplay function: observation × strategy × reward → passed reward
    coplay: Box<dyn Fn(&X, &Σ, &R) -> S>,

    /// Best response: observation × continuation → equilibrium strategies
    best_response: Box<dyn Fn(&X, &dyn Fn(&Y) -> R) -> Vec<Σ>>,
}

impl<X, Y, R, S, Σ> OpenGame<X, Y, R, S, Σ> {
    /// Sequential composition
    pub fn then<Z, T, Τ>(
        self,
        other: OpenGame<Y, Z, S, T, Τ>
    ) -> OpenGame<X, Z, R, T, (Σ, Τ)> {
        // Compose play functions
        // Compose coplay functions (backward)
        // Combine equilibrium conditions
        todo!()
    }
}
```

## Categorical Structure

Open games form a **symmetric monoidal category**:

| Structure | Meaning |
|-----------|---------|
| Objects | Type pairs (X, R) |
| Morphisms | Open games |
| Composition | Sequential play |
| Tensor | Parallel play |
| Identity | Pass-through game |

This is actually a **compact closed category** with additional structure for equilibrium.

## Applications

### Multi-Agent Reinforcement Learning

Each agent is an open game:
```
         ┌─────────┐
  obs ──▶│  Agent  │───▶ action
         │         │
reward ◀─│         │◀─── env_feedback
         └─────────┘
```

Compose agents with environment:
```
         ┌─────────┐     ┌─────────┐
         │ Agent 1 │◀───▶│         │
         └─────────┘     │   Env   │
         ┌─────────┐     │         │
         │ Agent 2 │◀───▶│         │
         └─────────┘     └─────────┘
```

### Mechanism Design

Design incentive structures compositionally:
- Auction as composition of bidding games
- Swap payment rules without changing bidding structure
- Analyze equilibria modularly

### Economic Modeling

Build complex economic models from simple parts:
- Firms, consumers, markets as open games
- Compose to form general equilibrium
- Modify one sector without rebuilding everything

## String Diagrams for Games

Open games have a natural string diagram representation:

```
Sequential:
    ─────┬─────┬─────
         │  G  │
    ─────┴─────┴─────
              ↓
    ─────┬─────┬─────
         │  H  │
    ─────┴─────┴─────

Parallel:
    ─────┬─────┬─────
         │  G  │
    ─────┴─────┴─────

    ─────┬─────┬─────
         │  H  │
    ─────┴─────┴─────
```

The backward-flowing wires carry utility information.

## Equilibrium Composition

**Key theorem**: If G and H are each in equilibrium, their composition G;H may or may not be in equilibrium.

This is where game theory gets interesting! The categorical structure tells us:
- When equilibria compose
- How to compute composite equilibria
- What additional conditions are needed

## Connection to Other Sessions

| Session | Connection |
|---------|------------|
| Session 3 | Functors preserve game structure |
| Session 7 | Lenses as special open games |
| Session 15-16 | DisCoCat uses similar bidirectional structure |
| Session 18 | Monoidal categories formalize composition |

## Exercises

1. **Simple game**: Model rock-paper-scissors as an open game. What are the types X, Y, R, S?

2. **Composition**: Given two sequential decisions, write out the composed play and coplay functions.

3. **Swap objective**: Take a prisoner's dilemma and swap the utility function from self-interested to altruistic. How does the equilibrium change?

4. **Parallel games**: Model two independent coin-flip betting games. Show their tensor product.

## Summary

| Concept | Description |
|---------|-------------|
| Open game | Morphism with forward (play) and backward (coplay) |
| Composition | Sequential play with backward utility flow |
| Tensor | Parallel independent games |
| Equilibrium | Strategy profiles satisfying best-response |
| Swappability | Change policy/env/objective independently |

## Reading

- Ghani, Hedges, Winschel, Zahn: "Compositional Game Theory" (2018)
- Hedges: "Morphisms of Open Games" (blog post)
- Fong, Spivak: "Seven Sketches" Chapter 4 (backpropagation as lenses)
- Riley: "Categories of Optics" (generalizes lenses)

## Next

Session 18: Monoidal Categories and String Diagrams — the general framework underlying DisCoCat, open games, and more.
