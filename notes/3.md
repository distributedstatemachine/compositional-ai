# Session 3: Functors and Natural Transformations

## Overview

A **functor** is a structure-preserving map between categories. A **natural transformation** is a map between functors that is "uniform across all objects."

These concepts are essential because they appear throughout the course:
- Session 9 (Autodiff): Backward pass is a functor to the opposite category
- Session 15 (DisCoCat): Semantics functor maps grammar to vector spaces
- Session 19 (Operads): Operad algebras are functors

## Key Concepts

### What is a Functor?

A **functor F: C → D** between categories C and D consists of:

1. **Object mapping**: For each object A in C, an object F(A) in D
2. **Morphism mapping**: For each morphism f: A → B in C, a morphism F(f): F(A) → F(B) in D

Such that:

**Preserves identity:**
```
F(id_A) = id_{F(A)}
```

**Preserves composition:**
```
F(g ∘ f) = F(g) ∘ F(f)
```

### Diagram

```
Category C                    Category D
                    F
    A ─────────────────────► F(A)
    │                          │
  f │                    F(f)  │
    ▼                          ▼
    B ─────────────────────► F(B)
    │                          │
  g │                    F(g)  │
    ▼                          ▼
    C ─────────────────────► F(C)

Functors preserve arrows AND their composition!
```

## Examples of Functors

### 1. Identity Functor

```
Id: C → C
Id(A) = A
Id(f) = f
```

Does nothing — the "no-op" functor.

### 2. Forgetful Functor

From groups to sets:
```
U: Grp → Set
U(G) = underlying set of G
U(f) = f (as a function)
```

"Forgets" the group structure, keeping only the set.

### 3. Free Functor

From sets to monoids:
```
Free: Set → Mon
Free(S) = monoid of lists over S
Free(f)(w) = apply f to each element of word w
```

Creates a monoid "for free" from a set.

### 4. Powerset Functor

```
P: Set → Set
P(A) = set of all subsets of A
P(f)(S) = { f(x) | x ∈ S }
```

Maps a set to its powerset.

### 5. List Functor (Programming)

```
List: Type → Type
List(A) = [A]
List(f) = map(f)  -- apply f to each element
```

The `map` operation is exactly the functor action!

## The Opposite Category and Contravariant Functors

### Opposite Category

For any category C, the **opposite category C^op** has:
- Same objects as C
- Arrows reversed: f: A → B in C becomes f: B → A in C^op
- Composition reversed: g ∘ f in C^op = f ∘ g in C

### Contravariant Functors

A **contravariant functor** F: C → D is equivalently:
- A functor F: C^op → D (from the opposite)
- Reverses arrows: f: A → B becomes F(f): F(B) → F(A)

**Example**: The Hom functor Hom(−, X) is contravariant in the first argument:
```
f: A → B
Hom(f, X): Hom(B, X) → Hom(A, X)
Hom(f, X)(g) = g ∘ f  -- precomposition
```

## Natural Transformations

A **natural transformation** η: F ⇒ G between functors F, G: C → D consists of:

For each object A in C, a morphism η_A: F(A) → G(A) in D, such that:

**Naturality square commutes:**
```
For any f: A → B in C:

F(A) ──η_A──► G(A)
 │              │
F(f)          G(f)
 │              │
 ▼              ▼
F(B) ──η_B──► G(B)

G(f) ∘ η_A = η_B ∘ F(f)
```

### Why "Natural"?

The transformation is "uniform" — it doesn't depend on which specific object you're looking at. The same pattern (η) works for all objects, and commutes with all morphisms.

**Example**: The "reverse list" operation:
```
rev: List ⇒ List
rev_A: [A] → [A]
rev_A([a, b, c]) = [c, b, a]

For any f: A → B:
map(f) ∘ rev_A = rev_B ∘ map(f)

-- Reverse then map = Map then reverse
```

## Implementation

### Finite Category

```rust
use std::collections::HashMap;

/// A finite category (for demonstration)
#[derive(Debug, Clone)]
pub struct FiniteCategory {
    /// Objects by name
    pub objects: Vec<String>,
    /// Morphisms: (source, target) → morphism name
    pub morphisms: HashMap<(String, String), Vec<String>>,
    /// Composition table: (f, g) → f ; g (if composable)
    pub composition: HashMap<(String, String), String>,
    /// Identity morphisms: object → identity name
    pub identities: HashMap<String, String>,
}

impl FiniteCategory {
    /// Compose two morphisms (if possible)
    pub fn compose(&self, f: &str, g: &str) -> Option<String> {
        self.composition.get(&(f.to_string(), g.to_string())).cloned()
    }

    /// Get the identity morphism for an object
    pub fn identity(&self, obj: &str) -> Option<String> {
        self.identities.get(obj).cloned()
    }
}
```

### Functor Trait

```rust
/// A functor from category C to category D
pub trait Functor<C, D> {
    /// Map an object from C to D
    fn map_obj(&self, obj: &str) -> String;

    /// Map a morphism from C to D
    fn map_mor(&self, mor: &str) -> String;

    /// Check that this functor preserves identities and composition
    fn check_laws(&self, c: &C, d: &D) -> bool
    where
        C: Category,
        D: Category;
}
```

### Opposite Category

```rust
/// The opposite of a category (arrows reversed)
pub struct OppositeCategory<C> {
    pub base: C,
}

impl<C: Clone> OppositeCategory<C> {
    pub fn new(base: C) -> Self {
        Self { base }
    }
}

impl OppositeCategory<FiniteCategory> {
    /// In the opposite category, composition is reversed
    pub fn compose(&self, f: &str, g: &str) -> Option<String> {
        // f ; g in C^op = g ; f in C
        self.base.compose(g, f)
    }
}
```

### Natural Transformation

```rust
/// A natural transformation between functors
pub struct NaturalTransformation<F, G> {
    /// Component at each object: η_A: F(A) → G(A)
    pub components: HashMap<String, String>,
    pub source: F,
    pub target: G,
}

impl<F, G> NaturalTransformation<F, G>
where
    F: Functor<FiniteCategory, FiniteCategory>,
    G: Functor<FiniteCategory, FiniteCategory>,
{
    /// Check naturality: G(f) ∘ η_A = η_B ∘ F(f)
    pub fn check_naturality(
        &self,
        f: &str,
        source_obj: &str,
        target_obj: &str,
        target_cat: &FiniteCategory,
    ) -> bool {
        let eta_a = self.components.get(source_obj).unwrap();
        let eta_b = self.components.get(target_obj).unwrap();

        let f_mapped = self.source.map_mor(f);
        let g_mapped = self.target.map_mor(f);

        // Left path: G(f) ∘ η_A
        let left = target_cat.compose(eta_a, &g_mapped);

        // Right path: η_B ∘ F(f)
        let right = target_cat.compose(&f_mapped, eta_b);

        left == right
    }
}
```

## Why Functors Matter for This Course

### Session 9: Autodiff as a Functor

The backward pass defines a functor:
```
Backprop: ForwardGraph → ForwardGraph^op
```

- Objects (tensors) map to gradient tensors
- Forward operations map to backward operations (reversed!)

### Session 15: Semantics Functor

DisCoCat uses a functor:
```
⟦−⟧: Grammar → FdVect
```

- Noun type N maps to noun space ℝⁿ
- Sentence type S maps to sentence space ℝ
- Grammatical reductions map to tensor contractions

### Session 19: Operad Algebras

An operad algebra is a functor:
```
O → EndomorphismOperad(X)
```

Mapping abstract operations to concrete implementations.

## Exercises

1. **Identity functor**: Prove that the identity functor preserves composition and identities.

2. **List functor**: Show that `map(g) ∘ map(f) = map(g ∘ f)` (functor law).

3. **Opposite category**: If f: A → B and g: B → C in C, what is (f ; g) in C^op?

4. **Naturality**: For the length function `len: List ⇒ Const(ℕ)`, draw the naturality square and verify it commutes.

5. **Contravariant functor**: Define a contravariant functor from Set to Set using function spaces.

## Summary

| Concept | Definition |
|---------|------------|
| Functor | Structure-preserving map F: C → D |
| F(id) = id | Preserves identities |
| F(g ∘ f) = F(g) ∘ F(f) | Preserves composition |
| Natural transformation | Uniform family of morphisms η: F ⇒ G |
| Naturality | G(f) ∘ η_A = η_B ∘ F(f) |
| Opposite category | Arrows reversed |
| Contravariant | Functor from C^op |

## Reading

- Leinster: Chapters 2-3 (Functors, Natural Transformations)
- Milewski: "Functors" and "Natural Transformations" chapters
- Awodey: Chapter 4 (Functors)

## Next

Session 3.5 (Optional): Coproducts and Yoneda — scope merging and dynamic capability discovery.
